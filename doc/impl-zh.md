## 文件

LevelDB 的实现与 [Bigtable tablet 的实现（第 5.3 节）](https://research.google/pubs/pub27898/) 在精神上是类似的。然而，其表示所涉及的文件组织有所不同，具体如下所述。

每个数据库由存储在一个目录中的一组文件表示。这些文件有以下几种类型：

### 日志文件

日志文件（*.log）存储一系列最近的更新。每次更新都会追加到当前日志文件。当日志文件达到预设的大小（默认约为 4MB）时，会将其转换为排序表（详见下文），并创建一个新的日志文件以存储后续更新。

当前日志文件的副本会保存在内存结构（`memtable`）中。读取操作会参考此副本，从而确保读操作反映所有记录的更新。

### 排序表

排序表（*.ldb）存储按键排序的条目序列。每个条目要么是键的值，要么是键的删除标记。（删除标记用于隐藏旧排序表中存在的过时值。）

排序表按层次结构组织。由日志文件生成的排序表被放置在一个特殊的**年轻层**（也称为 level-0）。当年轻层的文件数超过某个阈值（当前为四个）时，所有年轻层的文件会与所有重叠的 level-1 文件合并，生成一组新的 level-1 文件（每 2MB 数据生成一个新的 level-1 文件）。

年轻层的文件可能包含重叠的键。然而，其他层的文件具有明确的非重叠键范围。对于编号为 L（L ≥ 1）的层，当 L 层文件的总大小超过 (10^L) MB（例如，level-1 为 10MB，level-2 为 100MB，以此类推）时，会将 level-L 中的一个文件及其所有重叠的 level-(L+1) 文件合并，形成一组新的 level-(L+1) 文件。这些合并通过批量读取和写入（即最小化昂贵的随机访问）逐步将新的更新从年轻层迁移到最大层。

### Manifest 文件

MANIFEST 文件列出了组成每一层的排序表集合、对应的键范围，以及其他重要元数据。每次重新打开数据库时，都会创建一个新的 MANIFEST 文件（文件名中嵌入新的编号）。MANIFEST 文件的格式为日志文件，任何对服务状态的更改（如文件的添加或删除）都会追加到此日志中。

### Current 文件

`CURRENT` 是一个简单的文本文件，包含最新 MANIFEST 文件的名称。

### 信息日志

信息性消息会打印到名为 `LOG` 和 `LOG.old` 的文件中。

### 其他文件

数据库目录中还可能存在用于其他用途的文件（如 `LOCK`、`*.dbtmp`）。

---

## Level 0（年轻层）

当日志文件的大小超过一定阈值（默认 4MB）时：

创建一个新的 `memtable` 和日志文件，将后续更新指向新的日志文件。

在后台完成以下操作：
1. 将前一个 `memtable` 的内容写入一个 sstable（排序表）。
2. 丢弃旧的 `memtable`。
3. 删除旧的日志文件和 `memtable`。
4. 将新的 sstable 添加到年轻层（Level-0）。

---

## 压缩（Compactions）

当某层（Level L）的大小超出其限制时，会在后台线程中对其进行压缩。压缩过程会从 Level L 选择一个文件，并选择所有与之重叠的 Level-(L+1) 文件。需要注意的是，即使 Level-(L+1) 文件只有一部分与 Level-L 文件重叠，该文件也会作为输入并在压缩完成后被丢弃。

由于 Level-0 的特殊性（其文件可能彼此重叠），从 Level-0 压缩到 Level-1 时需要特殊处理：如果 Level-0 的文件相互重叠，压缩可能会选择多个 Level-0 文件。

压缩会合并选定文件的内容，生成一组新的 Level-(L+1) 文件。当当前输出文件的大小达到目标文件大小（2MB）时，切换到生成新的 Level-(L+1) 文件。此外，当当前输出文件的键范围扩大到与超过十个 Level-(L+2) 文件重叠时，也会切换到新的输出文件。这条规则确保后续压缩 Level-(L+1) 文件时不会从 Level-(L+2) 中读取过多数据。

旧文件会被丢弃，新文件会被加入服务状态。

每一层的压缩过程会在键空间中循环进行。具体而言，对于某个 Level L，会记录上一次压缩的结束键。下一次压缩会选择从该键之后开始的第一个文件（如果没有这样的文件，则从键空间的起始位置开始）。

压缩过程中，会丢弃被覆盖的值。此外，如果没有更高层包含键范围与当前键重叠的文件，则会丢弃删除标记。

### 时序分析

Level-0 的压缩操作最多会读取四个 1MB 的 Level-0 文件，以及最坏情况下所有 10MB 的 Level-1 文件。也就是说，压缩过程将读取 14MB 并写入 14MB 数据。

除了特殊的 Level-0 压缩之外，其余压缩操作会从 Level L 选择一个 2MB 的文件。在最坏情况下，该文件会与 Level-(L+1) 的大约 12 个文件重叠（由于 Level-(L+1) 的大小是 Level-L 的 10 倍，因此会有 10 个文件重叠，再加上边界上可能的两个文件，因为 Level-L 和 Level-(L+1) 的文件范围通常不对齐）。因此，压缩过程将读取 26MB 并写入 26MB 数据。假设磁盘 IO 速率为 100MB/s（现代驱动器的典型值），最坏情况下的压缩成本大约为 0.5 秒。

如果我们将后台写入速率限制为较低的水平，比如完整速率的 10%（即 10MB/s），一次压缩可能需要长达 5 秒。如果用户的写入速率为 10MB/s，那么可能会积累大量的 Level-0 文件（大约 50 个以容纳 5×10MB 数据）。这会显著增加读取成本，因为每次读取都需要合并更多的文件。

#### 解决方案

1. **增加日志切换阈值：**  
   当 Level-0 文件数量较多时，可以考虑增加日志文件的切换阈值。但缺点是，阈值越大，需要的内存也会越多以容纳相应的 memtable。

2. **降低写入速率：**  
   当 Level-0 文件数量增加时，可以人工降低写入速率。

3. **优化宽范围合并的成本：**  
   减少合并开销。或许大多数 Level-0 文件的块已经在缓存中解压缩，因此仅需关注合并迭代器的 O(N) 复杂度问题。

---

### 文件数量

为了减少总文件数量，我们可以在较高的层级中生成更大的文件，而不是总是生成 2MB 的文件，但这可能会导致压缩更加突发性地进行。  
另一个方案是将文件集合分片存储到多个目录中。

#### 实验数据

在 2011 年 2 月 4 日的一次实验中，使用 ext3 文件系统测量了包含不同数量文件的目录中打开 10 万个文件所需的时间：

| 目录中文件数量 | 打开一个文件所需时间（微秒） |
|-----------------|-----------------------------|
|            1000 |                           9 |
|           10000 |                          10 |
|          100000 |                          16 |

这表明在现代文件系统上，或许并不需要进行文件分片？

## 恢复（Recovery）

1. 读取 `CURRENT` 文件以获取最新提交的 MANIFEST 文件的名称。  
2. 读取上述命名的 MANIFEST 文件。  
3. 清理陈旧文件。  
4. 可以在此时打开所有 sstable 文件，但延迟加载可能是更好的选择……  
5. 将日志片段转换为新的 Level-0 sstable 文件。  
6. 启动新的日志文件，并使用恢复的序列号记录新写入的数据。  

---

## 文件的垃圾回收

在每次压缩结束时以及恢复结束时都会调用 `RemoveObsoleteFiles()` 方法。其操作如下：  

- 获取数据库中所有文件的名称。  
- 删除所有非当前日志文件的日志文件。  
- 删除所有未被任何层级引用且未处于活动压缩输出中的表文件。  
### LevelDB 日志格式

LevelDB 日志文件由一系列 32KB 的块组成。唯一的例外是文件的尾部可能包含一个部分块。

每个块由一系列记录构成：

```
block := record* trailer?
record :=
  checksum: uint32     // type 和 data[] 的 crc32c 校验和；小端格式
  length: uint16       // 记录的长度；小端格式
  type: uint8          // 记录的类型之一：FULL、FIRST、MIDDLE 或 LAST
  data: uint8[length]  // 数据内容
```

记录永远不会从块的最后 6 个字节内开始（因为没有足够空间）。这些剩余的字节形成一个 **trailer**，其内容必须完全是零字节，并且读取时必须跳过这些字节。

**补充说明**：如果当前块中恰好剩下 7 个字节，而需要写入一个新的非零长度记录，则写入器必须发出一个 **FIRST** 类型的记录（其中不包含用户数据），以填充块尾部的 7 个字节，随后将在接下来的块中写入所有用户数据。

未来可能会增加更多的记录类型。一些读取器可能跳过不理解的记录类型，另一些则可能报告跳过了某些数据。

```
FULL == 1
FIRST == 2
MIDDLE == 3
LAST == 4
```

- **FULL**：包含整个用户记录的完整内容。
- **FIRST、MIDDLE、LAST**：用于标识被分割为多个片段的用户记录（通常是由于块边界导致的分割）。  
  - **FIRST**：用户记录的第一个片段。
  - **MIDDLE**：用户记录的中间片段。
  - **LAST**：用户记录的最后一个片段。

---

### 示例

假设以下用户记录序列：

```
A: 长度 1000
B: 长度 97270
C: 长度 8000
```

- A 将作为一个 **FULL** 记录存储在第一个块中。
- B 将被分割为三个片段：

  第一个片段占据第一个块的剩余空间。

  第二个片段占据整个第二个块。

  第三个片段占据第三个块的前缀部分，剩余 6 个字节将作为空的 trailer。
- C 将作为一个 **FULL** 记录存储在第四个块中。

---

### 相较于 RecordIO 格式的优点

1. **无需复杂的重新同步机制**  
   只需跳转到下一个块的边界并扫描。如果检测到损坏，跳过该块即可。此外，当一个日志文件的部分内容嵌入到另一个日志文件中作为记录时，不会造成混淆。

2. **易于按近似边界分割（例如用于 MapReduce）**  
   只需找到下一个块的边界，跳过记录直到遇到 **FULL** 或 **FIRST** 记录即可。

3. **无需为大记录额外缓冲**  
   格式本身支持分割大记录，无需额外处理。

---

### 相较于 RecordIO 格式的缺点

1. **无法压缩小记录**  
   当前实现中没有对小记录进行打包，但这一限制可以通过添加新的记录类型解决，因此这是实现的不足，而非格式的局限。

2. **没有压缩机制**  
   同样，这可以通过引入新的记录类型来解决。